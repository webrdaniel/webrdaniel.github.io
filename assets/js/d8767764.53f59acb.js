"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["95970"],{36456:function(e,t,n){n.r(t),n.d(t,{default:()=>d,frontMatter:()=>o,metadata:()=>r,assets:()=>c,toc:()=>u,contentTitle:()=>l});var r=JSON.parse('{"id":"guides/parallel-scraping/parallel-scraping-guide","title":"Parallel Scraping Guide","description":"Parallelizing your scrapers with Crawlee","source":"@site/versioned_docs/version-3.7/guides/parallel-scraping/parallel-scraping.mdx","sourceDirName":"guides/parallel-scraping","slug":"/guides/parallel-scraping/","permalink":"/docs/3.7/guides/parallel-scraping/","draft":false,"unlisted":false,"editUrl":"https://github.com/apify/crawlee/edit/master/website/versioned_docs/version-3.7/guides/parallel-scraping/parallel-scraping.mdx","tags":[],"version":"3.7","lastUpdatedBy":"Vlad Frangu","lastUpdatedAt":1704796065000,"frontMatter":{"id":"parallel-scraping-guide","title":"Parallel Scraping Guide","sidebar_label":"Parallel Scraping","description":"Parallelizing your scrapers with Crawlee"},"sidebar":"docs","previous":{"title":"Running in Docker","permalink":"/docs/3.7/guides/docker-images"},"next":{"title":"Deployment","permalink":"/docs/3.7/deployment"}}'),a=n("85893"),s=n("50065"),i=n("96199");let o={id:"parallel-scraping-guide",title:"Parallel Scraping Guide",sidebar_label:"Parallel Scraping",description:"Parallelizing your scrapers with Crawlee"},l=void 0,c={},u=[{value:"Things to consider before parallelizing",id:"things-to-consider-before-parallelizing",level:2},{value:"But isn&#39;t Crawlee already concurrent? What&#39;s the difference between concurrency and parallelization?",id:"but-isnt-crawlee-already-concurrent-whats-the-difference-between-concurrency-and-parallelization",level:3},{value:"Preparing your scraper for parallelization",id:"preparing-your-scraper-for-parallelization",level:2},{value:"Creating the request queue with locking support",id:"creating-the-request-queue-with-locking-support",level:3},{value:"Adapting our previous scraper to enqueue the product URLs to the new queue",id:"adapting-our-previous-scraper-to-enqueue-the-product-urls-to-the-new-queue",level:3},{value:"Creating the parallel scrapers",id:"creating-the-parallel-scrapers",level:3},{value:"The <code>if</code> check for <code>process.env.IS_WORKER_THREAD</code>",id:"the-if-check-for-processenvis_worker_thread",level:4},{value:"Why do we create a Promise per worker process?",id:"why-do-we-create-a-promise-per-worker-process",level:4},{value:"What&#39;s with all those <code>Configuration</code> calls?",id:"whats-with-all-those-configuration-calls",level:4},{value:"Enabling the request locking experiment, and telling the crawler to use the worker configuration",id:"enabling-the-request-locking-experiment-and-telling-the-crawler-to-use-the-worker-configuration",level:4},{value:"Why do we use <code>process.send</code> instead of <code>context.pushData</code>?",id:"why-do-we-use-processsend-instead-of-contextpushdata",level:4},{value:"Why did we limit the maximum concurrency to <code>5</code>?",id:"why-did-we-limit-the-maximum-concurrency-to-5",level:4},{value:"Other questions",id:"other-questions",level:2},{value:"Couldn&#39;t the <code>initial-scraper</code> be merged into the <code>parallel-scraper</code>?",id:"couldnt-the-initial-scraper-be-merged-into-the-parallel-scraper",level:4},{value:"Will I benefit from this if I run XYZ scraper / want to scrape XYZ website?",id:"will-i-benefit-from-this-if-i-run-xyz-scraper--want-to-scrape-xyz-website",level:4}];function h(e){let t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.admonition,{title:"Experimental features ahead",type:"warning",children:(0,a.jsxs)(t.p,{children:["At the time of writing this guide (December 2023), request locking is still an experimental feature. You can read more about the experiment by visiting the ",(0,a.jsx)(t.a,{href:"../experiments/experiments-request-locking",children:"request locking experiment"})," page."]})}),"\n",(0,a.jsxs)(t.p,{children:["In this guide, we will walk you through how you can turn your single scraper into a scraper that can be parallelized and run in multiple instances. This guide assumes you've read and walked through our ",(0,a.jsx)(t.a,{href:"../introduction/setting-up",children:"introduction guide"})," (or have a fully-fledged scraper already built), but if you haven't done so yet, take a break, go read through all that, and come back. We'll be waiting..."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"Oh, you're back already! Let's proceed in making that scraper parallel!"})}),"\n",(0,a.jsx)(t.h2,{id:"things-to-consider-before-parallelizing",children:"Things to consider before parallelizing"}),"\n",(0,a.jsx)(t.p,{children:"Before you rush ahead and change your scraper to support parallelization, take a minute to consider the following factors:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Do you plan on scraping so many pages that you need to parallelize your scraper?","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"For example, if your scraper goes across a few pages, you probably don't need parallelization"}),"\n",(0,a.jsx)(t.li,{children:"But if you scrape a lot of pages, or you scrape pages that take a long time to load, you might want to consider parallelization"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["Can you parallelize your scraper while not overloading the target website?","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"For example, if you scrape a website that has a lot of traffic, you don't want to add to that traffic by running multiple scrapers in parallel as that might cause the website to go down for all its users"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["Do you have the resources available to run multiple scrapers in parallel?","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"When running locally, depending on your scraper type, do you have enough CPU and RAM available to sustain multiple scrapers running in parallel"}),"\n",(0,a.jsx)(t.li,{children:"When running in the cloud, will the extra speed from parallelization be worth the extra cost of running multiple scrapers in parallel?"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Let's assume you answered yes to all of those. Yes? Yes. Before we go ahead and get to the actual guide, we'd like to ask you to also take a read on ",(0,a.jsx)(t.a,{href:"https://blog.apify.com/what-is-ethical-web-scraping-and-how-do-you-do-it/",target:"_blank",rel:"noopener",children:"Apify's Ethical Web Scraping"}),"\nblog post!"]}),"\n",(0,a.jsxs)(t.p,{children:["Now that we've gone through all that, the guide is split into two parts: converting the initial scraper we built in the ",(0,a.jsx)(t.a,{href:"../introduction/setting-up",children:"introduction guide"})," to one that prepares requests to be usable in parallel scrapers, and then running scrapers in parallel."]}),"\n",(0,a.jsx)(t.admonition,{title:"Want to see the final result?",type:"note",children:(0,a.jsxs)(t.p,{children:["You can see it on the ",(0,a.jsx)(t.a,{href:"https://github.com/apify/crawlee-parallel-scraping-example",target:"_blank",rel:"noopener",children:"Crawlee Parallel Scraping Example"})," repository! It's the same scraper we built in the ",(0,a.jsx)(t.a,{href:"../introduction/setting-up",children:"introduction guide"}),", but in TypeScript and parallelized!"]})}),"\n",(0,a.jsx)(t.h3,{id:"but-isnt-crawlee-already-concurrent-whats-the-difference-between-concurrency-and-parallelization",children:"But isn't Crawlee already concurrent? What's the difference between concurrency and parallelization?"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.em,{children:["Hold on! I've used Crawlee before, and it has a ",(0,a.jsx)(t.code,{children:"maxConcurrency"})," option! What's this for then?!"]})}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"You're correct, Crawlee already supports scraping in \"parallel\" (more accurately called concurrent). What that enables is one process having multiple tasks that run in the background at the same time. But, as your scraping operation scales up, you are likely to encounter bottlenecks. These can range from the runtime environment's inability to process more requests simultaneously, to resources like RAM and CPU being maxed out. You can only scale up resources so much before it stops providing a real benefit."}),"\n",(0,a.jsx)(t.p,{children:'This is what people refer to when saying vertical or horizontal scaling. Vertical scaling is when you increase the resources of a single process or machine, while horizontal scaling is when you increase the number of processes or machines. Horizontal scaling, on the other hand, is the kind of scaling (or what we\'re referring to as "parallelization") we are showcasing in this guide!'}),"\n",(0,a.jsx)(t.h2,{id:"preparing-your-scraper-for-parallelization",children:"Preparing your scraper for parallelization"}),"\n",(0,a.jsx)(t.p,{children:"One of the best parts of Crawlee is that, for the most part, we do not need to change much to make this happen! Just create the queue that supports locking, enqueue links to it from the initial scraper, then build scrapers that run in parallel that use that queue!"}),"\n",(0,a.jsx)(t.h3,{id:"creating-the-request-queue-with-locking-support",children:"Creating the request queue with locking support"}),"\n",(0,a.jsxs)(t.p,{children:["The first step in our conversion process will be creating a common file (let's call it ",(0,a.jsx)(t.code,{children:"requestQueue.mjs"}),") that will store the request queue that supports request locking."]}),"\n",(0,a.jsx)(i.default,{language:"js",title:"src/requestQueue.mjs",children:"import { RequestQueueV2 } from 'crawlee';\n\n// Create the request queue that also supports parallelization\nlet queue;\n\n/**\n * @param {boolean} makeFresh Whether the queue should be cleared before returning it\n * @returns The queue\n */\nexport async function getOrInitQueue(makeFresh = false) {\n    if (queue) {\n        return queue;\n    }\n\n    queue = await RequestQueueV2.open('shop-urls');\n\n    if (makeFresh) {\n        await queue.drop();\n        queue = await RequestQueueV2.open('shop-urls');\n    }\n\n    return queue;\n}\n"}),"\n",(0,a.jsxs)(t.p,{children:["The exported function, ",(0,a.jsx)(t.code,{children:"getOrInitQueue"}),", might seem like it does a lot. In essence, it just ensures the request queue is initialized, and if requested, ensures it starts off with an empty state."]}),"\n",(0,a.jsx)(t.h3,{id:"adapting-our-previous-scraper-to-enqueue-the-product-urls-to-the-new-queue",children:"Adapting our previous scraper to enqueue the product URLs to the new queue"}),"\n",(0,a.jsxs)(t.p,{children:["In the ",(0,a.jsx)(t.code,{children:"src/routes.mjs"})," file of the scraper we previously built, we have a handler for the ",(0,a.jsx)(t.code,{children:"CATEGORY"})," label. Let's adapt that handler to enqueue the product URLs to the new queue we created."]}),"\n",(0,a.jsxs)(t.p,{children:["Firstly, let's import the ",(0,a.jsx)(t.code,{children:"getOrInitQueue"})," function from the ",(0,a.jsx)(t.code,{children:"requestQueue.mjs"})," file we created earlier. Add the following line at the start of the file:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",metastring:'title="src/routes.mjs"',children:"import { getOrInitQueue } from './requestQueue.mjs';\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Then, replace the ",(0,a.jsx)(t.code,{children:"CATEGORY"})," handler with the following:"]}),"\n",(0,a.jsx)(i.default,{language:"js",title:"src/routes.mjs",children:"router.addHandler('CATEGORY', async ({ page, enqueueLinks, request, log }) => {\n    log.debug(`Enqueueing pagination for: ${request.url}`);\n    // We are now on a category page. We can use this to paginate through and enqueue all products,\n    // as well as any subsequent pages we find\n\n    await page.waitForSelector('.product-item > a');\n    await enqueueLinks({\n        selector: '.product-item > a',\n        label: 'DETAIL', // <= note the different label,\n        // highlight-next-line\n        requestQueue: await getOrInitQueue(), // <= note the different request queue\n    });\n\n    // Now we need to find the \"Next\" button and enqueue the next page of results (if it exists)\n    const nextButton = await page.$('a.pagination__next');\n    if (nextButton) {\n        await enqueueLinks({\n            selector: 'a.pagination__next',\n            label: 'CATEGORY', // <= note the same label\n        });\n    }\n});\n"}),"\n",(0,a.jsxs)(t.p,{children:["Now, let's rename our entry point file ",(0,a.jsx)(t.code,{children:"src/main.mjs"})," to ",(0,a.jsx)(t.code,{children:"src/initial-scraper.mjs"})," and run it. You should see the crawler not scrape any detail pages, but now the URLs are being enqueued to the queue that supports locking!"]}),"\n",(0,a.jsxs)(t.p,{children:["Before we wrap up, let's also add the following line before ",(0,a.jsx)(t.code,{children:"crawler.run()"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",metastring:'title="src/initial-scraper.mjs"',children:"import { getOrInitQueue } from './requestQueue.mjs';\n\n// Pre-initialize the queue so that we have a blank slate that will get filled out by the crawler\nawait getOrInitQueue(true);\n"})}),"\n",(0,a.jsx)(t.p,{children:"We need this to ensure the queue always starts on an empty slate when we run the scraper. But you may not need this in your use case - remember to always experiment and see what works best!"}),"\n",(0,a.jsx)(t.p,{children:"And that's it with preparing our initial scraper to save all URLs we want to scrape to the queue that supports locking!"}),"\n",(0,a.jsx)(t.h3,{id:"creating-the-parallel-scrapers",children:"Creating the parallel scrapers"}),"\n",(0,a.jsx)(t.p,{children:"Up next, let's build another scraper that will schedule the URLs from the queue to be scraped in parallel! For this, we will be using child processes from Node.js,\nbut you can use any other method you want to run multiple scrapers in parallel. You will need to adjust your code if you use other methods."}),"\n",(0,a.jsx)(t.p,{children:"The scraper will fork itself twice (but you can experiment with this), and each fork will re-use the queue we created earlier.\nThe best part? We can re-use the previous router we built for the initial scraper! Yay for code reuse!"}),"\n",(0,a.jsx)(i.default,{language:"js",title:"src/parallel-scraper.mjs",children:"import { fork } from 'node:child_process';\n\nimport { Configuration, Dataset, PlaywrightCrawler, log } from 'crawlee';\n\nimport { router } from './routes.mjs';\nimport { getOrInitQueue } from './shared.mjs';\n\n// For this example, we will spawn 2 separate processes that will scrape the store in parallel.\n\nif (!process.env.IN_WORKER_THREAD) {\n    // This is the main process. We will use this to spawn the worker threads.\n    log.info('Setting up worker threads.');\n\n    const currentFile = new URL(import.meta.url).pathname;\n\n    // Store a promise per worker, so we wait for all to finish before exiting the main process\n    const promises = [];\n\n    // You can decide how many workers you want to spawn, but keep in mind you can only spawn so many before you overload your machine\n    for (let i = 0; i < 2; i++) {\n        const proc = fork(currentFile, {\n            env: {\n                // Share the current process's env across to the newly created process\n                ...process.env,\n                // ...but also tell the process that it's a worker process\n                IN_WORKER_THREAD: 'true',\n                // ...as well as which worker it is\n                WORKER_INDEX: String(i),\n            },\n        });\n\n        proc.on('online', () => {\n            log.info(`Process ${i} is online.`);\n\n            // Log out what the crawlers are doing\n            // Note: we want to use console.log instead of log.info because we already get formatted output from the crawlers\n            proc.stdout.on('data', (data) => {\n                // eslint-disable-next-line no-console\n                console.log(data.toString());\n            });\n\n            proc.stderr.on('data', (data) => {\n                // eslint-disable-next-line no-console\n                console.error(data.toString());\n            });\n        });\n\n        proc.on('message', async (data) => {\n            log.debug(`Process ${i} sent data.`, data);\n            await Dataset.pushData(data);\n        });\n\n        promises.push(new Promise((resolve) => {\n            proc.once('exit', (code, signal) => {\n                log.info(`Process ${i} exited with code ${code} and signal ${signal}`);\n                resolve();\n            });\n        }));\n    }\n\n    await Promise.all(promises);\n\n    log.info('Crawling complete!');\n} else {\n    // This is the worker process. We will use this to scrape the store.\n\n    // Let's build a logger that will prefix the log messages with the worker index\n    const workerLogger = log.child({ prefix: `[Worker ${process.env.WORKER_INDEX}]` });\n\n    // This is better set with CRAWLEE_LOG_LEVEL env var\n    // or a configuration option. This is just for show \uD83D\uDE08\n    workerLogger.setLevel(log.LEVELS.DEBUG);\n\n    // Disable the automatic purge on start\n    // This is needed when running locally, as otherwise multiple processes will try to clear the default storage (and that will cause clashes)\n    Configuration.set('purgeOnStart', false);\n\n    // Get the request queue\n    const requestQueue = await getOrInitQueue(false);\n\n    // Configure crawlee to store the worker-specific data in a separate directory (needs to be done AFTER the queue is initialized when running locally)\n    const config = new Configuration({\n        storageClientOptions: {\n            localDataDirectory: `./storage/worker-${process.env.WORKER_INDEX}`,\n        },\n    });\n\n    workerLogger.debug('Setting up crawler.');\n    const crawler = new PlaywrightCrawler({\n        log: workerLogger,\n        // Instead of the long requestHandler with\n        // if clauses we provide a router instance.\n        requestHandler: router,\n        // Enable the request locking experiment so that we can actually use the queue.\n        // highlight-start\n        experiments: {\n            requestLocking: true,\n        },\n        // Provide the request queue we've pre-filled in previous steps\n        requestQueue,\n        // highlight-end\n        // Let's also limit the crawler's concurrency, we don't want to overload a single process \uD83D\uDC0C\n        maxConcurrency: 5,\n    }, config);\n\n    await crawler.run();\n}\n"}),"\n",(0,a.jsxs)(t.p,{children:["We'll also need to do one small change in the ",(0,a.jsx)(t.code,{children:"DETAIL"})," route handler. Instead of calling ",(0,a.jsx)(t.code,{children:"context.pushData"}),", we want to replace that with ",(0,a.jsx)(t.code,{children:"process.send"})," instead."]}),"\n",(0,a.jsxs)(t.admonition,{title:"But why?",type:"info",children:[(0,a.jsxs)(t.p,{children:["Since we use child processes, and each worker process has its own storage space, calling ",(0,a.jsx)(t.code,{children:"context.pushData"})," will not work as we want it to work.\nInstead, we need to send the data back to the parent process, which has the context where we want to store the data."]}),(0,a.jsx)(t.p,{children:"This might not be needed depending on your use case! You'll need to experiment and see what works best for you"})]}),"\n",(0,a.jsx)(i.default,{language:"js",title:"src/routes.mjs",children:"// This replaces the request.label === DETAIL branch of the if clause.\nrouter.addHandler('DETAIL', async ({ request, page, log }) => {\n    log.debug(`Extracting data: ${request.url}`);\n    const urlPart = request.url.split('/').slice(-1); // ['sennheiser-mke-440-professional-stereo-shotgun-microphone-mke-440']\n    const manufacturer = urlPart[0].split('-')[0]; // 'sennheiser'\n\n    const title = await page.locator('.product-meta h1').textContent();\n    const sku = await page\n        .locator('span.product-meta__sku-number')\n        .textContent();\n\n    const priceElement = page\n        .locator('span.price')\n        .filter({\n            hasText: '$',\n        })\n        .first();\n\n    const currentPriceString = await priceElement.textContent();\n    const rawPrice = currentPriceString.split('$')[1];\n    const price = Number(rawPrice.replaceAll(',', ''));\n\n    const inStockElement = page\n        .locator('span.product-form__inventory')\n        .filter({\n            hasText: 'In stock',\n        })\n        .first();\n\n    const inStock = (await inStockElement.count()) > 0;\n\n    const results = {\n        url: request.url,\n        manufacturer,\n        title,\n        sku,\n        currentPrice: price,\n        availableInStock: inStock,\n    };\n\n    log.debug(`Saving data: ${request.url}`);\n\n    // Send the data to the parent process\n    // Depending on how you build your crawler, this line could instead be something like `context.pushData()`! Experiment, and see what you can build\n    // highlight-next-line\n    process.send(results);\n});\n"}),"\n",(0,a.jsx)(t.p,{children:"There is a lot of code, so let's break it down:"}),"\n",(0,a.jsxs)(t.h4,{id:"the-if-check-for-processenvis_worker_thread",children:["The ",(0,a.jsx)(t.code,{children:"if"})," check for ",(0,a.jsx)(t.code,{children:"process.env.IS_WORKER_THREAD"})]}),"\n",(0,a.jsxs)(t.p,{children:["This will check how the script is executed as. If this value has ",(0,a.jsx)(t.em,{children:"any"})," value, it will assume it's meant to start scraping. If not, it's considered the ",(0,a.jsx)(t.strong,{children:"parent"})," process and will fork copies of itself to do the scraping."]}),"\n",(0,a.jsx)(t.h4,{id:"why-do-we-create-a-promise-per-worker-process",children:"Why do we create a Promise per worker process?"}),"\n",(0,a.jsx)(t.p,{children:"We use this to ensure the parent process stays alive until all the worker processes exit. Otherwise, the worker processes would just get spawned, and lose the ability to communicate with the parent. You might not need this depending on your use case (maybe you just need to spawn workers and let them process)."}),"\n",(0,a.jsxs)(t.h4,{id:"whats-with-all-those-configuration-calls",children:["What's with all those ",(0,a.jsx)(t.code,{children:"Configuration"})," calls?"]}),"\n",(0,a.jsx)(t.p,{children:"There are three steps we want to do for the worker processes:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["ensure the default storages do ",(0,a.jsx)(t.strong,{children:"not"})," get purged on start, as otherwise we'd lose the queue we prepared"]}),"\n",(0,a.jsx)(t.li,{children:"get the queue that supports locking from the same location as the parent process"}),"\n",(0,a.jsx)(t.li,{children:"initialize a special storage for worker processes so they do not collide with each other"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"In order, that's what these lines do:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",metastring:'title="src/parallel-scraper.mjs"',children:"// Disable the automatic purge on start (step 1)\n// This is needed when running locally, as otherwise multiple processes will try to clear the default storage (and that will cause clashes)\nConfiguration.set('purgeOnStart', false);\n\n// Get the request queue from the parent process (step 2)\nconst requestQueue = await getOrInitQueue(false);\n\n// Configure crawlee to store the worker-specific data in a separate directory (needs to be done AFTER the queue is initialized when running locally) (step 3)\nconst config = new Configuration({\n    storageClientOptions: {\n        localDataDirectory: `./storage/worker-${process.env.WORKER_INDEX}`,\n    },\n});\n"})}),"\n",(0,a.jsx)(t.h4,{id:"enabling-the-request-locking-experiment-and-telling-the-crawler-to-use-the-worker-configuration",children:"Enabling the request locking experiment, and telling the crawler to use the worker configuration"}),"\n",(0,a.jsxs)(t.p,{children:["You might have noticed several lines highlighted in the code above. Those show how you can enable the request locking experiment, as well as how you provide the request queue to the crawler. You can read more about the experiment by visiting the ",(0,a.jsx)(t.a,{href:"../experiments/experiments-request-locking",children:"request locking experiment"})," page."]}),"\n",(0,a.jsxs)(t.p,{children:["You might have also noticed we passed in a second parameter to the constructor of the crawler, the ",(0,a.jsx)(t.code,{children:"config"})," variable we created earlier. This is needed to ensure the crawler uses the worker-specific storages for internal states, and that they do not collide with each other."]}),"\n",(0,a.jsxs)(t.h4,{id:"why-do-we-use-processsend-instead-of-contextpushdata",children:["Why do we use ",(0,a.jsx)(t.code,{children:"process.send"})," instead of ",(0,a.jsx)(t.code,{children:"context.pushData"}),"?"]}),"\n",(0,a.jsxs)(t.p,{children:["Since we use child processes, and each worker process has its own storage space, calling ",(0,a.jsx)(t.code,{children:"context.pushData"}),' will not work as we want it to work (each worker would just push to its own personal dataset that is considered the "default" one). Instead, we need to send the data back to the parent process, which has the dataset where we want to store the data, in a centralized place.']}),"\n",(0,a.jsxs)(t.admonition,{title:"Why don't we apply the same logic we did to the request queue to the dataset?",type:"info",children:[(0,a.jsx)(t.p,{children:"This is a very valid question, but it has a simple answer: since each process tracks its own internal state of how a dataset looks like (when we are scrapping locally), the worker processes would get out of sync real fast and would either miss or override data. This is why we need to send the data back to the parent process, which has the dataset where we want to store the data, in a centralized place."}),(0,a.jsx)(t.p,{children:"Depending on your crawler, this might not be an issue! Each use case has its own quirks, but this is something you should keep in mind when building your scraper."})]}),"\n",(0,a.jsxs)(t.h4,{id:"why-did-we-limit-the-maximum-concurrency-to-5",children:["Why did we limit the maximum concurrency to ",(0,a.jsx)(t.code,{children:"5"}),"?"]}),"\n",(0,a.jsx)(t.p,{children:"This question has a two-fold answer:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"we don't want to overload the target website with requests, so we limit the number of concurrent requests to a reasonable number per worker process"}),"\n",(0,a.jsx)(t.li,{children:"we don't want to overload the machine that is running the scraper"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"This circles back to the initial paragraph about whether you should parallelize your scraper or not."}),"\n",(0,a.jsx)(t.h2,{id:"other-questions",children:"Other questions"}),"\n",(0,a.jsxs)(t.h4,{id:"couldnt-the-initial-scraper-be-merged-into-the-parallel-scraper",children:["Couldn't the ",(0,a.jsx)(t.code,{children:"initial-scraper"})," be merged into the ",(0,a.jsx)(t.code,{children:"parallel-scraper"}),"?"]}),"\n",(0,a.jsx)(t.p,{children:"Technically, it could! Nothing stops you from first enqueuing all the URLs in the parent process, and then run the worker process logic after to scrape them. We separated them so it's easier to follow and understand what each part does, but you can merge them if you want to."}),"\n",(0,a.jsx)(t.h4,{id:"will-i-benefit-from-this-if-i-run-xyz-scraper--want-to-scrape-xyz-website",children:"Will I benefit from this if I run XYZ scraper / want to scrape XYZ website?"}),"\n",(0,a.jsx)(t.p,{children:"We don't know! \uD83E\uDD37"}),"\n",(0,a.jsx)(t.p,{children:"What we do know is that first, you should build your scraper to work as a single scraper, then monitor its performance. Do you see it being too slow? Do you scrape many pages, or do the few pages you scrape take a long time to load? If so, then you might benefit from parallelization. When in doubt, follow the list of things to consider before parallelizing at the start of this guide."})]})}function d(e={}){let{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},50065:function(e,t,n){n.d(t,{Z:function(){return o},a:function(){return i}});var r=n(67294);let a={},s=r.createContext(a);function i(e){let t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);